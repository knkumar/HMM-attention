function [hmm] = getHMM_null(x)
  
  hmm.emit.all.prob = [];
  hmm.n.bins = 100;
  hmm.n.states = 8;

  % transition probabilities of going from one target to another or staying
  % on a target. It is a symmetric matrix.
  if (x(1)+x(2)) < 1
    x_rem = (1-(x(1)+x(2)))/4;
  else
    x(1) = 0.7;
    x(2) = 0.1;
    x_rem = 0.05;
  end

  % transition probabilities of going from one target to another or staying
  % on a target. (It is a symmetric matrix.)
  hmm.trans = [ x(1), x(2), 1.5*x_rem, 0, 1.5*x_rem, 0, x_rem/2, x_rem/2;...
                x(2), x(1), 1.5*x_rem, 0, 1.5*x_rem, 0, x_rem, 0;...
                1.5*x_rem, 0, x(1), x(2), 1.5*x_rem, 0, x_rem/2, x_rem/2;...
                1.5*x_rem, 0, x(2), x(1), 1.5*x_rem, 0, x_rem, 0;...
                1.5*x_rem, 0, 1.5*x_rem, 0, x(1), x(2), x_rem/2, x_rem/2;...
                1.5*x_rem, 0, 1.5*x_rem, 0, x(2), x(1), x_rem, 0;...
                x_rem, x_rem, x_rem, x_rem, x_rem, x_rem, x(1)-(2*x_rem), x(2);...
                2*x_rem, 0, 2*x_rem, 0, 2*x_rem, 0, x(2), x(1)-(2*x_rem)];

  xdist   = x(3:6);
  xorient = x(7:8);
  xvel    = x(9:11);
  xacc    = x(12:13);
  
  xdist(1) = max(0,xdist(1));
  xdist(2) = xdist(2) * 900;
  xdist(3 )= max(0.1,xdist(3)); % handle gamma for zero 
  xdist(4) = xdist(4) * 40;

  xorient = [0, xorient(1), 0, xorient(2)];
  xorient(2) = xorient(2) * 30;
  xorient(4) = xorient(4) * 180;

  % 10,4 are bad
  xvel = [xvel(1), xvel(2), 1, xvel(3)];
  xvel = max(0.1,xvel); % handle gamma for zero 
  xvel(1) = xvel(1) * 5;
  xvel(2) = xvel(2) * 20;
  xvel(4) = xvel(4) * 0.4;

  xacc = [0, xacc(1), xacc(2),0];
  xacc(2) = xacc(2) * 40;
  xacc(3) = xacc(3) * -10;

  hmm.emit.names = {'distance','orientation','velocity','acceleration'};

  % setting up the emission probability distributions
  hmm.emit.distance.dist = {...
      'unif',xdist(1),xdist(2);...
      'gam',xdist(3),xdist(4);...
      'unif',xdist(1),xdist(2);...
      'gam',xdist(3),xdist(4);...
      'unif',xdist(1),xdist(2);...
      'gam',xdist(3),xdist(4);...
      'unif',xdist(1),xdist(2);...
      'gam',xdist(3), xdist(4) }; % set distance to almost center
  hmm.emit.distance.range = [0,1000];
  hmm.emit.distance.offset = 1;
  hmm.emit.distance.order = [1,1,2,2,3,3,4,4];

  hmm.emit.orientation.dist = {...
      'norm',xorient(1),xorient(2);...
      'unif',xorient(3),xorient(4);...
      'norm',xorient(1),xorient(2);...
      'unif',xorient(3),xorient(4);...
      'norm',xorient(1),xorient(2);...
      'unif',xorient(3),xorient(4);...
      'norm',xorient(1),xorient(2);... % set orientation to very directly to the target
      'unif',xorient(3),xorient(4) };
  hmm.emit.orientation.range = [0,180];
  hmm.emit.orientation.offset = 1; %(hmm.n.bins/2)+1;
  hmm.emit.orientation.order = [1,1,2,2,3,3,4,4];
  
  hmm.emit.velocity.dist = {...
      'gam',xvel(1),xvel(2);...
      'gam',xvel(3),xvel(4);...
      'gam',xvel(1),xvel(2);...
      'gam',xvel(3),xvel(4);...
      'gam',xvel(1),xvel(2);...
      'gam',xvel(3),xvel(4);...
      'gam',xvel(1),xvel(2);...
      'gam', xvel(3), xvel(4) }; % set velocity to stop
  hmm.emit.velocity.range = [0,100];
  hmm.emit.velocity.offset = 1;
  hmm.emit.velocity.order = [1,1,1,1,1,1,1,1];

  hmm.emit.acceleration.dist ={...
      'unif',xacc(1),xacc(2);...
      'unif',xacc(3),xacc(4);...
      'unif',xacc(1),xacc(2);...
      'unif',xacc(3),xacc(4);...
      'unif',xacc(1),xacc(2);...
      'unif',xacc(3),xacc(4);...
      'unif',xacc(1),xacc(2);...
      'unif',xacc(3),xacc(4) };
  hmm.emit.acceleration.range = [-10,40];
  hmm.emit.acceleration.offset = 1;
  hmm.emit.acceleration.order = [1,1,1,1,1,1,1,1];
  
end
